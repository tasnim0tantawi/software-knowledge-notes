
<h1> Backend Handover Document - Laravel </h1>

# Table of Contents
- [Introduction](#introduction)
- [Setting up Laravel](#1-setting-up-laravel)
    * [Installation - Cloning Github Projects](#installation---cloning-github-projects)
    * [Installation - Starting a New Project](#installation---starting-a-new-project)
- [Laravel Project Structure and Code Snippets](#2-laravel-project-structure-and-code-snippets)
    * [Controllers](#1-controllers)
    * [Form Requests](#2-form-requests)
    * [API Resources](#3-api-resources)
    * [Console/Commands](#4-console-commands)
    * [Middleware](#5-middleware)
    * [Jobs](#6-jobs)
    * [Notifications](#7-notifications)
    * [Policies](#8-policies)
    * [Services](#9-services)
- [Useful Laravel Packages](#3-useful-laravel-packages)
    * [Laravel Sanctum - API Authentication](#1-laravel-sanctum---api-authentication)
    * [Telescope - Debugging and Monitoring Tool in Development Environment](#2-telescope---debugging-and-monitoring-tool-in-development-environment)
    * [Laravel Horizon - Queue Management Tool](#3-laravel-horizon---queue-management-tool)
    * [Laravel Pint - Code Quality Tool](#4-laravel-pint---code-quality-tool)
    * [Spatie Backup - Database Backup Tool](#5-spatie-backup---database-backup-tool)
    * [Laravel Scout - Full-Text Search Tool](#6-laravel-scout---full-text-search-tool)




# Introduction
This document includes information about the general project structure, code snippets, and useful Laravel packages. 


# 1. Setting up Laravel

## Installation - Starting a New Project
### Step 1: Create a Laravel Project using Composer

```bash
composer create-project laravel/laravel project-name
cd project-name
```

### Step 2: Install Laravel API 
    
```bash
php artisan install:api
```

API installation will add the following:
- Laravel Sanctum
- API Route File

### Step 3: Do the steps from Step 3 in the previous section.



# 2. Laravel Project Structure and Code Snippets

```
project/
├── app/
│   ├── Console/
│   ├── Http/
│   │   ├── Controllers/
│   │   ├── Middleware/
│   │   ├── Requests/
│   │   └── Resources/
│   ├── Jobs/
│   ├── Models/
│   ├── Policies/
│   └── Services/
├── config/
├── database/
│   ├── migrations/
│   └── seeders/
├── routes/
├── storage/
├── tests/
├── resources/
├── public/
└── ...
```

## 1. Controllers

Controllers are used to handle incoming requests and return responses. Controllers should not contain a lot of logic. Instead, the logic should be moved to services or models.

### Example 1:

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Requests\Appointment\AppointmentTimeSlotsRequest;
use App\Http\Requests\Appointment\CancelAppointmentRequest;
use App\Http\Requests\Appointment\ServiceCenterRequest;
use App\Http\Requests\Appointment\TimeSlotsRequest;
use App\Http\Requests\StoreAppointmentRequest;
use App\Http\Requests\UpdateAppointmentRequest;
use App\Http\Resources\AppointmentResource;
use App\Localization\Message;
use App\Models\Appointment;
use App\Models\City;
use App\Models\ServiceType;
use App\Models\Vehicle;
use App\Notifications\AppointmentBookedNotification;
use App\Services\AppointmentService;
use App\Types\HTTPResponse;
use Carbon\Carbon;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;

class AppointmentController extends Controller
{
    private AppointmentService $appointmentService;

    public function __construct()
    {
        $this->appointmentService = new AppointmentService();
    }

    public function index(): AnonymousResourceCollection
    {
        // get current user appointments
        $appointments = Appointment::latest()->paginate(config('admc.PAGE_SIZE'));

        return AppointmentResource::collection($appointments);

    }

    public function getMyUpcomingAppointments(): AnonymousResourceCollection
    {
        $customer = auth()->user()->customer;

        $appointments = $customer->appointments()->where('date_time', '>=', now())->latest()->get();

        return AppointmentResource::collection($appointments);
    }

    public function getServiceCenters(ServiceCenterRequest $request): JsonResponse
    {
        $data = $request->validated();
        $serviceCategory = 'Maintenance Service';
        $city = City::find($data['city_id']);
        $serviceType = ServiceType::find($data['service_type_id'])->name;

        $serviceCenters = $this->appointmentService->getServiceCenters([
            'service_type' => $serviceType,
            'service_category' => $serviceCategory,
            'city' => $city->english_name,
        ]);

        if ($serviceCenters === false) {
            return response()->json(['message' => Message::getError('appointmentCreateError')], HTTPResponse::INTERNAL_SERVER_ERROR);
        }

        return response()->json(['data' => $serviceCenters]);
    }

    public function getTimeSlots(TimeSlotsRequest $request): JsonResponse
    {
        $data = $request->validated();
        $serviceCenterId = $data['service_center_id'];
        $serviceCategory = 'Maintenance Service';
        $city = City::find($data['city_id']);
        $serviceType = ServiceType::find($data['service_type_id'])->name;

        $timeSlots = $this->appointmentService->getAppointmentDates([
            'service_type' => $serviceType,
            'service_category' => $serviceCategory,
            'city' => $city->english_name,
            'service_branch_id' => $serviceCenterId,
        ]);
        if ($timeSlots === false) {
            return response()->json(['message' => Message::getError('appointmentCreateError')], HTTPResponse::INTERNAL_SERVER_ERROR);
        }

        return response()->json(['data' => $timeSlots]);
    }
}
```
A controller that handles appointments. It contains methods to get appointments, get upcoming appointments for the current user, get service centers, and get time slots for appointments. It uses the `AppointmentService` to get service centers and time slots. It returns JSON responses with appointment data.




## 2. Form Requests

Form Requests are used for validating incoming requests before they reach the controller.  
Docs: [Laravel Validation Documentation](https://laravel.com/docs/11.x/validation#form-request-validation)

### Example 1:

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreFaqRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'question' => 'required|string',
            'arabic_question' => 'required|string',
            'answer' => 'required|string',
            'arabic_answer' => 'required|string',
            'is_active' => 'sometimes|boolean',
        ];
    }
}
```

### - Validation Rules:

- `rules()` function specifies validation rules. Common rules are:
    - `required`: The field is required.
    - `string - integer - boolean - array`: The field must be of the specified type.
    - `sometimes`: The field is required only if it is present in the request as a key.
    - `unique:table,column`: The field must be unique in the specified table and column.
    - `exists:table,column`: The field must exist in the specified table and column.
    - `in:val1,val2,...`: The field must be one of the specified values.
    - `max:value`: The field must be less than or equal to the specified value.
    - `min:value`: The field must be greater than or equal to the specified value.
    - `email`: The field must be a valid email address.
    - `confirmed`: The field must have a matching field of `field_name_confirmation`. Usually used for password confirmation.
    - `date`: The field must be a valid date.
    - `date_format:format`: The field must be a valid date in the specified format.
    - `regex:pattern`: The field must match the specified regular expression pattern.
    - `nullable`: The field can be null. The difference between `nullable` and `sometimes` is that `nullable` allows the field to be null, while `sometimes` requires the field to be provided if it is present in the request as a key.
    - `bail`: Stops running validation rules on the field after the first validation failure.
    - `gte:field`: The field must be greater than or equal to the specified field.
    - `lte:field`: The field must be less than or equal to the specified field.
    - `required_with:field1,field2,...`: The field is required only if any of the specified fields are present in the request.
    - `required_without:field1,field2,...`: The field is required only if none of the specified fields are present in the request.
    - `file`: The field must be a file.
    - `image`: The field must be an image (jpeg, png, bmp, gif, or svg).
    - `mimes:jpeg,png,bmp,gif,svg`: The field must be one of the specified file types.
    - `max:file_size`: The field must be less than or equal to the specified file size in kilobytes.
    - `min:file_size`: The field must be greater than or equal to the specified file size in kilobytes.

    #### The rest of the rules can be found in the [Laravel Validation Documentation](https://laravel.com/docs/11.x/validation#available-validation-rules).

    - Note that you can also create custom validation rules. Please refer to the [Laravel Validation Documentation](https://laravel.com/docs/11.x/validation#custom-validation-rules) for more information.

    - Note that you can also validate file uploads and passwords with more advanced rules. Please refer to the [Laravel Validation Documentation](https://laravel.com/docs/11.x/validation#validating-files) and [Laravel Validation Documentation](https://laravel.com/docs/11.x/validation#validating-passwords) for more information.


### - Customizing the Error Messages:
- messages() function can be used to customize the error messages.  
    ```php
    public function messages(): array
    {
        return [
            'question.required' => 'Please provide a question.',
            'question.string' => 'The question must be in a text format.',
            'arabic_question.required' => 'Please provide an Arabic translation for the question.',
            'arabic_question.string' => 'The Arabic question must be in a text format.',
            'answer.required' => 'Please provide an answer to the question.',
            'answer.string' => 'The answer must be in a text format.',
            'arabic_answer.required' => 'The Arabic answer field is required.',
            'arabic_answer.string' => 'The Arabic answer field must be a string.',
            'is_active.boolean' => 'The is active field must be a boolean (0 or 1).'
        ];
    }
    ```

### - Customizing the Error Response:
- failedValidation() function can be used to customize the error response.  
    ```php
    protected function failedValidation(Validator $validator): void
    {
        $errorResponse = [
            'message' => 'The given data was invalid.',
            'errors' => $validator->errors(),
        ];

        throw new HttpResponseException(
            response()->json($errorResponse, HTTPResponse::UNPROCESSABLE_ENTITY)
        );
    }
    ```
    - The `HTTPResponse` class is a custom class that contains HTTP status codes.
    - The `HttpResponseException` class is used to throw an exception that will be caught by the Laravel error handler and converted into a JSON response.


### Example 2:

```php
<?php

namespace App\Http\Requests;

use App\Types\HTTPResponse;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Http\Exceptions.HttpResponseException;

class UpdateVehicleRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user()->can('update', $this->vehicle);
    }

    public function rules(): array
    {
        return [
            'external_color' => 'sometimes|string',
            'license_plate' => 'sometimes|string',
            'nickname' => 'sometimes|string',
            'mileage' => 'sometimes|integer',
        ];
    }

    protected function failedAuthorization(): void
    {
        $errorResponse = [
            'message' => 'You are not authorized to update this vehicle.',
        ];

        throw new HttpResponseException(
            response()->json($errorResponse, HTTPResponse::FORBIDDEN)
        );
    }
}
```


## 3. API Resources

API Resources are used to transform models into JSON responses.  
Docs: [Laravel Eloquent Resources Documentation](https://laravel.com/docs/11.x/eloquent-resources)

### Example 1:

```php
<?php

namespace App\Http\Resources\Auth;

use App\Models\Admin;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class AdminResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        $admin = $this->admin;
        $invitedBy = Admin::find($this->admin->invited_by)?->user;

        return [
            'userId' => $this->id,
            'adminId' => $admin->id,
            'name' => $this->name,
            'email' => $this->email,
            'phone' => $this->phone,
            'language' => $this->language,
            'role' => 'Admin',
            'joinedAt' => $this->created_at->diffForHumans(),
            'phoneVerified' => (bool) $this->phone_verified_at,
            'emailVerified' => (bool) $this->email_verified_at,
            'invitedBy' => $this->admin->invited_by ? $invitedBy?->name.' ('.$invitedBy?->email.')'
                : 'None',
            'isAccepted' => $this->when($this->admin->invited_by, (bool) $this->admin->accepted_at),
            'acceptedAt' => $this->when($this->admin->invited_by, $this->admin->accepted_at ? $this->admin->accepted_at->diffForHumans() : null),
        ];
    }
}
```




## 4. Console/Commands
Console commands are used to create custom commands that can be run from the command line. Useful for running scheduled tasks, maintenance tasks, and other tasks that need to be run from the command line. 

### Example 1:
```php
<?php

namespace App\Console\Commands;

use App\Models\Appointment;
use App\Models\Customer;
use App\Models\Statistics;
use App\Models\Vehicle;
use Illuminate\Console\Command;

class UpdateStatisticsCommand extends Command
{
    protected $signature = 'statistics:update';

    protected $description = 'Update the statistics table';

    public function handle(): void
    {
        // get the last statistics record
        $lastStatistics = Statistics::latest()->first();
        $totalAppointments = Appointment::count();
        $totalCustomers = Customer::count();
        $totalVehicles = Vehicle::count();
        $appointmentsToday = Appointment::whereDate('created_at', now())->count();
        if ($lastStatistics && $lastStatistics->created_at->diffInDays(now()) < 7) {
            // update the last statistics record
            $lastStatistics->update([
                'total_appointments' => $totalAppointments,
                'total_customers' => $totalCustomers,
                'total_vehicles' => $totalVehicles,
                'appointments_today' => $appointmentsToday,
            ]);

        } else {
            // create a new statistics record
            Statistics::create([
                'total_appointments' => $totalAppointments,
                'total_customers' => $totalCustomers,
                'total_vehicles' => $totalVehicles,
                'appointments_today' => $appointmentsToday,
            ]);
        }

    }
}

```
This command can be run from the command line using the following command:
```bash
php artisan statistics:update
```

It will update the statistics table with the total number of appointments, customers, vehicles, and appointments today. It is useful for updating the statistics table on a regular basis (scheduled task that runs daily, weekly, etc.). 


## 5. Middleware

Middleware is used to filter HTTP requests before they reach the controller. Useful for authentication, authorization, and other tasks that need to be performed before the request reaches the controller.

### Example 1:
```php
<?php

namespace App\Http\Middleware;

use Carbon\Carbon;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class SetLocale
{
    public function handle(Request $request, Closure $next): Response
    {
        $language = substr($request->header('Accept-Language'), 0, 2);
        if ($language == 'ar') {
            app()->setLocale('ar');
            Carbon::setLocale('ar');

        } else {
            // save the locale in the session
            app()->setLocale('en');
            Carbon::setLocale('en');
        }

        return $next($request);
    }
}
```
This middleware sets the locale based on the `Accept-Language` header in the request. If the `Accept-Language` header is `ar`, it sets the locale to `ar` and the Carbon locale to `ar`. Otherwise, it sets the locale to `en` and the Carbon locale to `en`. It is useful for setting the locale based on the user's preferred language.

### Example 2:
```php
<?php

namespace App\Http\Middleware;

use App\Models\Admin;
use App\Types\HTTPResponse;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class IsAdmin
{
    public function handle(Request $request, Closure $next): Response
    {
        $user_id = $request->user()?->id;
        $admin = Admin::where('user_id', $user_id)->first();
        if (! $admin) {
            return response()->json(
                [
                    'message' => 'You are not authorized to perform this action',
                ], HTTPResponse:: FORBIDDEN
            );
        }

        return $next($request);
    }
}

```

This middleware checks if the user is an admin. If the user is not an admin, it returns a `403 Forbidden` response with the message "You are not authorized to perform this action". It is useful for restricting access to admin-only routes.


## 6. Jobs

Jobs are used to perform tasks in the background. Useful for sending emails, processing data, and other tasks that need to be performed asynchronously.

### Example 1:
```php
<?php

namespace App\Jobs;

use App\Models\Customer;
use App\Models\Invoice;
use App\Models\Receipt;
use App\Services\InvoiceReceiptService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Container\BindingResolutionException;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class CreateInvoiceJob implements ShouldQueue
{
    protected int $tries = 3;

    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected InvoiceReceiptService $invoiceReceiptService;

    protected Invoice $invoice;

    protected ?Receipt $receipt;

    public function __construct(Invoice $invoice, Customer $customer, ?Receipt $receipt = null)
    {
        $this->invoiceReceiptService = new InvoiceReceiptService($customer);
        $this->invoice = $invoice;
        $this->receipt = $receipt ?? null;

    }

    /**
     * @throws BindingResolutionException
     */
    public function handle(): void
    {
        ini_set('memory_limit', '64M');
        ini_set('max_execution_time', 300);
        $this->invoiceReceiptService->generateInvoice($this->invoice);
        //        $this->invoiceReceiptService->generateReceipt($this->receipt);
        // if the receipt is passed, then we need to generate a receipt
        if ($this->receipt) {
            $this->invoiceReceiptService->generateReceipt($this->receipt);
        }

    }
}

```

This job creates an invoice for a customer. It uses the `InvoiceReceiptService` to generate the invoice. It is useful for generating invoices in the background without blocking the main thread. As generating invoices can be a time-consuming task, it is better to perform it in the background using a job. 


## 7. Notifications

Notifications are used to send notifications to users via email, SMS, and other channels. Useful for sending notifications to users when certain events occur.

### Example 1:
```php
<?php

namespace App\Notifications\Auth;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use Illuminate\Notifications\Notification;
use Illuminate\Support\HtmlString;

class ResetPasswordNotification extends Notification implements ShouldQueue
{
    use Queueable;

    private string $otp;

    public function __construct(string $otp)
    {
        $this->otp = $otp;
    }

    public function via(object $notifiable): array
    {
        return ['mail'];
    }
    public function toMail(object $notifiable): MailMessage
    {
        return (new MailMessage)
            ->subject('Password Reset OTP')
            ->greeting('OTP: '.$this->otp)
            ->line(new HtmlString('<br>'))
            ->line(new HtmlString('<br>'))

            ->line(new HtmlString("Hi <strong>$notifiable->name</strong>, "))
            ->line('You are receiving this email because we received a password reset request for your account. The OTP will expire in '.config('admc.RESET_PASSWORD_OTP_EXPIRY', 15).' minutes. Do not share your OTP with anyone else.')
            ->line('If you did not request a password reset, no further action is required.')
            ->salutation('Regards, '.config('app.name'))
            ->markdown('vendor.notifications.email', ['locale' => app()->getLocale()]);
        
    }

}

```

This notification sends an email to the user with the OTP for resetting the password. It sends password reset OTPs to users when they request a password reset.



## 8. Policies

Policies are used to authorize actions on models. Useful for defining authorization logic for models. For example, you can define a policy that allows only the owner of a post to update or delete the post. You can also define a policy that allows only admins to perform certain actions.

### Example 1:
```php
<?php

namespace App\Policies;

use App\Models\User;
use App\Models\Vehicle;

class VehiclePolicy
{
    /**
     * Create a new policy instance.
     */
    public function create(User $user): bool
    {
        return $user->isCustomer();
    }

    public function view(User $user, Vehicle $vehicle): bool
    {
        return $user->customer->id === $vehicle->customer_id;
    }

    public function update(User $user, Vehicle $vehicle): bool
    {
        return $user->customer->id === $vehicle->customer_id;
    }

    public function delete(User $user, Vehicle $vehicle): bool
    {
        return $user->customer->id === $vehicle->customer_id;
    }
}

```

This policy defines authorization logic for the `Vehicle` model. It allows customers to create vehicles, view their own vehicles, update their own vehicles, and delete their own vehicles. It is useful for restricting access to vehicles based on the user's role and the owner of the vehicle.


## 9. Services

Services are used to encapsulate business logic. Useful for separating business logic from controllers and models. Services can be used to perform complex operations, interact with external APIs, and perform other tasks that require complex logic. It keeps the code clean and maintainable. It allows for reusability since the same service can be used in multiple controllers or models.

### Example 1:
```php
<?php

namespace App\Services;

use App\Localization\Message;
use App\Models\PasswordResetToken;
use App\Types\HTTPResponse;
use App\Types\TwilioResponse;
use Twilio\Rest\Client;

class TwilioService
{
    private string $sId;

    private string $token;

    private string $serviceSid;

    public function __construct()
    {
        $this->sId = config('services.twilio.sid');
        $this->token = config('services.twilio.token');
        $this->serviceSid = config('services.twilio.service_sid');
    }

    public function sendOtp(string $phone): TwilioResponse
    {
        if (str_contains($phone, '-')) {
            $phone = '+'.str_replace('-', '', $phone);
        }

        try {
            $twilio = new Client($this->sId, $this->token);
            $res = $twilio->verify->v2->services($this->serviceSid)
                ->verifications
                ->create($phone, 'sms');
            if ($res->status === 'pending') {
                return new TwilioResponse(
                    message: 'OTP sent successfully to '.$phone.'. Please note it will expire in 10 minutes.',
                    code: HTTPResponse::OK
                );
            }
        } catch (\Exception $e) {
            return new TwilioResponse(
                message: 'Failed to send OTP',
                code: HTTPResponse::INTERNAL_SERVER_ERROR
            );
        }

        return new TwilioResponse(
            message: 'Failed to send OTP',
            code: HTTPResponse::BAD_REQUEST
        );
    }

    /**
     * @throws \Exception
     */
    public function verifyOtp(string $phone, $otp): TwilioResponse
    {
        $originalPhone = $phone;
        if (str_contains($phone, '-')) {
            $phone = '+'.str_replace('-', '', $phone);
        }

        try {
            $twilio = new Client($this->sId, $this->token);
            $verification = $twilio->verify->v2->services($this->serviceSid)
                ->verificationChecks
                ->create(['to' => $phone, 'code' => $otp]);
            if ($verification->status !== 'approved') {
                return new TwilioResponse(
                    message: Message::getError('invalidOTP'),
                    code: HTTPResponse::UNAUTHORIZED
                );
            }
        } catch (\Exception $e) {
            return new TwilioResponse(
                message: 'Failed to verify OTP '.$e->getMessage(),
                code: HTTPResponse::INTERNAL_SERVER_ERROR
            );
        }

        $token = PasswordResetToken::where('phone', $originalPhone)->first();
        $token?->delete();

        $token = PasswordResetToken::create([
            'phone' => $originalPhone,
            'token' => bin2hex(random_bytes(32)),
        ]);

        return new TwilioResponse(
            message : Message::getSuccess('otpValid'),
            code: HTTPResponse::OK,
            phone: $phone,
            token: $token->token
        );
    }
}

```

This service interacts with the Twilio API to send OTPs to users and verify OTPs. It uses the Twilio PHP SDK to send and verify OTPs. It is useful for sending OTPs to users for phone number verification and password reset.

### Example 2:
```php
<?php

namespace App\Services;

use App\Types\HTTPResponse;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Http;

class AppointmentService
{
    public function getServiceCenters(array $data): false|array
    {

        $serviceType = $data['service_type'];
        $serviceCategory = $data['service_category'];
        $city = $data['city'];
        // url format {{TEST_LINK}}/AppointmentList_c?q=ServiceType_c="Quick Service";ServiceCategory_c="Maintenance Service";City_c="Jeddah";NoOfSlots_c>0
        $url = config('admc.API_URL').'/AppointmentList_c?q=ServiceType_c="'.$serviceType.'";ServiceCategory_c="'.$serviceCategory.'";City_c="'.$city.'";NoOfSlots_c>0';

        try {
            // send a get request to the API with USERNAME and PASSWORD
            $response = Http::withBasicAuth(config('admc.API_USERNAME'), config('admc.API_PASSWORD'))
                ->get($url);
            if ($response->status() !== HTTPResponse::OK) {
                return false;
            }
            $serviceCenters = $response->json()['items'];
            $responseData = [];

            if (! empty($serviceCenters)) {
                foreach ($serviceCenters as $serviceCenter) {
                    if ($serviceCenter['NoOfSlots_c'] > 0 && $serviceCenter['ServiceBranch_Id_c'] !== null && $serviceCenter['ServiceBranch_c'] !== null) {
                        $responseData[] = [
                            'sId' => $serviceCenter['ServiceBranch_Id_c'],
                            'name' => $serviceCenter['ServiceBranch_c'],
                            'cityName' => $serviceCenter['City_c'],
                            'serviceType' => $serviceCenter['ServiceType_c'],
                            'serviceCategory' => $serviceCenter['ServiceCategory_c'],
                        ];
                    }
                }
            }

            $uniqueIds = [];
            $responseData = array_filter($responseData, function ($serviceCenter) use (&$uniqueIds) {
                if (in_array($serviceCenter['sId'], $uniqueIds)) {
                    return false;
                }
                $uniqueIds[] = $serviceCenter['sId'];

                return true;
            });

            return $responseData;

        } catch (\Exception $e) {
            return false;
        }

    }


    public function createServiceRequest(array $data): false|array
    {
        $title = $data['title'];
        $customerIdC = $data['customer_id_c'];
        $serviceType = $data['service_type'];
        $serviceCenterName = $data['service_center_name'];
        $vehicleIdC = $data['vehicle_id_c'];
        $slotC = $data['slot_c'];
        $url = config('admc.API_URL').'/serviceRequests';

        try {
            // send a get request to the API with USERNAME and PASSWORD
            $response = Http::withBasicAuth(config('admc.API_USERNAME'), config('admc.API_PASSWORD'))
                ->post($url, [
                    'Title' => $title,
                    'PrimaryContactPartyNumber' => $customerIdC,
                    'ServiceType_c' => $serviceType,
                    'CommunicationMethod_c' => 'SMS',
                    'SRCategory_c' => 'Maintenance',
                    'CenterName_c' => $serviceCenterName,
                    'ServiceCategory_c' => 'Maintenance Service',
                    'VehicleName_Id_c' => $vehicleIdC,
                    //                    'FindSlot_c' => $slotC,
                ]);
            if ($response->status() !== HTTPResponse::CREATED) {
                return false;
            }

            return $response->json();

        } catch (\Exception $e) {
            return false;
        }
    }


    public function cancelAppointment($serviceRequestId, $cancellationReason): false|JsonResponse
    {
        $url = config('admc.API_URL').'/ServiceRequests/'.$serviceRequestId;

        try {
            $response = Http::withBasicAuth(config('admc.API_USERNAME'), config('admc.API_PASSWORD'))
                ->patch($url, [
                    'CancelFromMobile_c' => 'Y',
                    'CancellationReason_c' => $cancellationReason,
                ]);
            $data = $response->json();

            return response()->json($data);
        } catch (\Exception $e) {
            return false;
        }
    }
}

```

This service interacts with an external API to get service centers, create service requests, cancel appointments, and perform other tasks related to appointments. It uses the Laravel HTTP client to send requests to the API. The service also cleans and filters the data received from the API before returning it to the controller.


# 3. Useful Laravel Packages
In this section, we will list some useful Laravel packages that can help you build your Laravel application faster and more efficiently. T?hese packages are used in multiple Fathtom Media projects.

## 1. Laravel Sanctum - API Authentication
Laravel Sanctum provides a simple way to authenticate APIs. It is a lightweight package that provides token-based authentication for APIs. It is easy to set up and use. It is useful for securing APIs and authenticating users.

Docs: [Laravel Sanctum Documentation](https://laravel.com/docs/11.x/sanctum)


## 2. Telescope - Debugging and Monitoring Tool in Development Environment

Laravel Telescope is an elegant debug assistant for the Laravel framework. It provides insight into the requests coming into your application, exceptions, log entries, database queries, queued jobs, mail, notifications, cache operations, scheduled tasks, variable dumps, and more. Telescope makes a wonderful companion to your local Laravel development environment.

Docs: [Laravel Telescope Documentation](https://laravel.com/docs/11.x/telescope)

## 3. Laravel Horizon - Queue Management Tool

Laravel Horizon provides a beautiful dashboard and code-driven configuration for your Laravel powered Redis queues. Horizon allows you to easily monitor key metrics of your queue system such as job throughput, runtime, and job failures.

Docs: [Laravel Horizon Documentation](https://laravel.com/docs/11.x/horizon)

## 4. Laravel Pint - Code Quality Tool
Laravel Pint is an opinionated code styling tool for PHP, designed to ensure that your code follows a consistent and standard coding style. 

Docs: [Laravel Pint Documentation](https://laravel.com/docs/11.x/pint)

- Run the following command to format your code with Laravel Pint:
```bash
./vendor/bin/pint
```

## 5. Spatie Backup - Database Backup Tool
Spatie Backup is a package to help you take backups of your Laravel application. It can backup files and databases. It can also backup to multiple filesystems such as S3, FTP, SFTP, and more.


## 6. Laravel Daily/Laravel Invoice - Invoice Generation Tool
Laravel Daily is a package that provides a simple way to generate invoices in Laravel. It is useful for generating invoices for customers and clients. It can generate PDF invoices with a customizable template.

## 7. DOMPDF Wrapper for Laravel
DOMPDF Wrapper for Laravel is a package that provides a simple way to generate PDFs in Laravel. It uses the DOMPDF library to generate PDFs from HTML templates. It is useful for generating PDF reports, invoices, and other documents.

Docs: [DOMPDF Wrapper for Laravel Documentation](https://github.com/barryvdh/laravel-dompdf)

## 8. Spatie Media Library - Media Management Tool
Spatie Media Library is a package that provides a simple way to manage media files in Laravel. It allows you to associate media files with models and provides methods for uploading, storing, and retrieving media files. It is useful for managing images, videos, and other media files in your Laravel application.

Docs: [Spatie Media Library Documentation](https://spatie.be/docs/laravel-medialibrary/v11/introduction)

## 9. Spatie Activity Log - Logging Tool
Spatie Activity Log is a package that provides a simple way to log user activities in Laravel. It allows you to log user actions, changes to models, and other activities in your Laravel application. It is useful for tracking user actions, auditing changes, and monitoring activities in your application.

Docs: [Spatie Activity Log Documentation](https://spatie.be/docs/laravel-activitylog/v4/introduction)


## 10. Laravel Scout - Full-Text Search Tool

Laravel Scout provides a simple way to add full-text search to your Laravel application. It uses a search engine like Algolia to index and search your models. It is useful for adding search functionality to your application and improving the user experience.

Docs: [Laravel Scout Documentation](https://laravel.com/docs/11.x/scout)


# 4. Common Code

## 1. Emails and Notifications 
1. Publish the Laravel email templates to customize the email templates.
```bash
    php artisan vendor:publish --tag=laravel-mail
    php artisan vendor:publish --tag=laravel-notifications
```

2. Customize the email template in the `resources/views/vendor/notification` directory.

3. Add this block of code to the template to allow for Arabic localization.

```html
  @if( isset($locale) && $locale == 'ar')
    <head>
        <style>
            * {
                direction: rtl;
                text-align: right;
            }
        </style>
    </head>
@else
    <head>
        <style>
            * {
                direction: ltr;
                text-align: left;
            }
        </style>
    </head>
@endif

<x-mail::message>
{{-- Greeting --}}
@if (! empty($greeting))
 # the rest of the code
 . . .
```

4. Pass local in the notification class to the email template.
```php
    ->markdown('vendor.notifications.email', ['locale' => app()->getLocale()]);
```

5. Change the `text-align` and direction in the css file from left to start everywhere. In the `resources/views/vendor/notification/html/themes/default.css` file, add the following code:
```css
    h2 {
        text-align: start; /* Change from left to start */
    }
```

Full Example:
```php
<?php

namespace App\Notifications;

use App\Models\Appointment;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use Illuminate\Notifications\Notification;

class AppointmentBookedNotification extends Notification implements ShouldQueue
{
    use Queueable;

    private Appointment $appointment;

    public function __construct(Appointment $appointment)
    {
        $this->appointment = $appointment;
    }

    public function via(object $notifiable): array
    {
        return ['mail'];
    }

    public function toMail(object $notifiable): MailMessage
    {
        app()->setLocale($notifiable->language);
        if (app()->getLocale() == 'ar') {
            return (new MailMessage)
                ->subject('تم حجز موعدك بنجاح')
                ->greeting('مرحبًا! '.$notifiable->name)
                ->line('تم حجز موعدك بنجاح.')
                ->line('تفاصيل الموعد:')
                ->line('التاريخ: '.$this->appointment->date)
                ->line('الوقت: '.$this->appointment->time)
                ->line('الخدمة: '.$this->appointment->serviceType->name)
                ->line('المركبة: '.$this->appointment->vehicle->make.' '.$this->appointment->vehicle->model.' '.$this->appointment->vehicle->year)
                ->line('شكرًا لك وأتمنى لك يومًا سعيدًا!')
                ->salutation('مع تحيات, '.config('app.name'))
                ->markdown('vendor.notifications.email', ['locale' => app()->getLocale()]);
        } else {
            return (new MailMessage)
                ->greeting('Hello! '.$notifiable->name)
                ->line('Your appointment has been booked successfully.')
                ->line('Appointment Details:')
                ->line('Date: '.$this->appointment->date)
                ->line('Time: '.$this->appointment->time)
                ->line('Service: '.$this->appointment->serviceType->name)
                ->line('Vehicle: '.$this->appointment->vehicle->make.' '.$this->appointment->vehicle->model.' '.$this->appointment->vehicle->year)
                ->line('Thank you and have a great day!')
                ->salutation('Regards, '.config('app.name'))
                ->markdown('vendor.notifications.email', ['locale' => app()->getLocale()]);

        }
    }

    public function toArray(object $notifiable): array
    {
        return [
            //
        ];
    }
}
    
```
**Notes:**
1. Always save the preferred language of the user in the database. `$notifiable->language` is the language of the user, and it should be saved in the database when the user registers or updates their profile.

2. Always set the locale in the notification class to the user's preferred language. This will ensure that the email template is rendered in the correct language.



## 2. Localization
Localization can be implemented in various ways. The way it is done in Fathom is by translationg the API response messages, validation messages, and email templates in both English and Arabic.

1. Create a localization middleware to set the locale based on the user's preferred language or the `Accept-Language` header in the request. 
```php
<?php

namespace App\Http\Middleware;

use Carbon\Carbon;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class SetLocale
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        $language = substr($request->header('Accept-Language'), 0, 2);
        if ($language == 'ar') {
            app()->setLocale('ar');
            Carbon::setLocale('ar');

        } else {
            // save the locale in the session
            app()->setLocale('en');
            Carbon::setLocale('en');
        }

        return $next($request);
    }
}
```

2. Create a Message class to store the translated messages in `app/Localization/Message.php`.
```php
<?php

namespace App\Localization;

use App\Localization\Lang\Arabic;
use App\Localization\Lang\English;

class Message
{
    protected static $langs = [
        'ar' => Arabic::class,
        'en' => English::class,
    ];

    public static function getSuccess(string $key): string
    {
        $local = app()->getLocale();
        if (! isset(self::$langs[$local])) {
            $local = 'en';
        }

        return self::$langs[$local]::getSuccessMessage($key);
    }

    public static function getError(string $key): string
    {
        $local = app()->getLocale();
        if (! isset(self::$langs[$local])) {
            $local = 'en';
        }

        return self::$langs[$local]::getErrorMessage($key);
    }
}
```


3. Create a directory `app/Localization/Lang` and create two files `Arabic.php` and `English.php` to store the translated messages.

```php
<?php

namespace App\Localization\Lang;

class Arabic
{
    public static array $successMessages = [
        'auth' => [
            'login' => 'مرحبًا بك ، تم تسجيل الدخول بنجاح',
            'logout' => 'تم تسجيل الخروج بنجاح',
            'register' => 'تم إنشاء حسابك بنجاح. يرجى التحقق من حسابك باستخدام الرمز المرسل إلى بريدك الإلكتروني.',
            'resetPassword' => 'تم إرسال رمز التحقق بنجاح إلى بريدك الإلكتروني. الرجاد استخدام هذا الرمز لإعادة تعيين كلمة المرور الخاصة بك.',
            'changePassword' => 'تم تغيير كلمة المرور بنجاح',
            'verifyEmail' => 'تم التحقق من بريدك الإلكتروني بنجاح',
            'resendEmailVerification' => 'تم إعادة إرسال رمز التحقق إلى بريدك الإلكتروني',
            'updateEmailOTPSent' => 'يرجى التحقق من بريدك الإلكتروني الجديد لتأكيد التغيير من خلال رمز التحقق المرسل إليك',
            'emailVerified' => 'تم التحقق من بريدك الإلكتروني بنجاح',
            'updatePhone' => 'تم تحديث رقم هاتفك بنجاح',
        ],
        'appointment' => [
            'appointmentCancelled' => 'تم إلغاء الموعد بنجاح',
            'appointmentUpdated' => 'تم تحديث الموعد بنجاح',
            'appointmentCreated' => 'تم حجز الموعد بنجاح',
        ],
        'vehicle' => [
            'vehicleDeleted' => 'تم حذف المركبة بنجاح',
            'vehicleUpdated' => 'تم تحديث المركبة بنجاح',
            'vehicleCreated' => 'تم إضافة المركبة بنجاح',
            'vehicleDetached' => 'تم فك الارتباط بين المركبة والعميل بنجاح',
        ],
        'serviceType' => [
            'serviceTypeDeleted' => 'تم حذف نوع الخدمة بنجاح',
            'serviceTypeUpdated' => 'تم تحديث نوع الخدمة بنجاح',
            'serviceTypeCreated' => 'تم إضافة نوع الخدمة بنجاح',
        ],
        'city' => [
            'cityDeleted' => 'تم حذف المدينة بنجاح',
            'cityUpdated' => 'تم تحديث المدينة بنجاح',
            'cityCreated' => 'تم إضافة المدينة بنجاح',
        ],
    ];

    public static array $errorMessages = [
        'auth' => [
            'invalidOTP' => 'رمز التحقق غير صالح',
            'expiredOTP' => 'انتهت صلاحية رمز التحقق',
            'invalidEmailOrPassword' => 'خطأ في البريد الإلكتروني أو كلمة المرور',
            'emailNotMatch' => 'البريد الإلكتروني غير متطابق',
            'emailAlreadyVerified' => 'تم التحقق من البريد الإلكتروني بالفعل',
            'error' => 'حدث خطأ ما ، يرجى المحاولة مرة أخرى',

        ],
        'vehicle' => [
            'vehicleNotFound' => 'المركبة غير موجودة',
            'errorDetachVehicle' => 'حدث خطأ أثناء حذف المركبة. يرجى المحاولة مرة أخرى',
        ],
        'appointment' => [
            'appointmentError' => 'حدث خطأ أثناء إنشاء الموعد',
            'timeSlotNotAvailable' => 'الوقت غير متاح',
            'invalidCustomer' => 'العميل غير صالح',
            'requiredServiceType' => 'نوع الخدمة مطلوب',
        ],
        'customer' => [
            'customerNotSuspended' => 'العميل ليس محظورًا',
            'customerAlreadySuspended' => 'العميل محظور بالفعل',
        ],
    
    ];

    public static function getSuccessMessage(string $key)
    {
        foreach (self::$successMessages as $category => $messages) {
            if (isset($messages[$key])) {
                return $messages[$key];
            }
        }

        return 'تمت العملية بنجاح';
    }

    public static function getErrorMessage(string $key)
    {
        foreach (self::$errorMessages as $category => $messages) {
            if (isset($messages[$key])) {
                return $messages[$key];
            }
        }

        return 'حدث خطأ ما ، يرجى المحاولة مرة أخرى';
    }
}
```

4. Use the `Message` class to get the translated messages in the application.
```php
    return response()->json(
        [
            'message' => Message::getSuccess('appointmentCreated'),
            'appointment' => new AppointmentResource($appointment),
        ], HTTPResponse::CREATED
    );
```


## 3. Firebase Cloud Messaging (FCM)
1. Create a Firebase project and add the Firebase configuration to the Laravel application.
2. Install the `google/apiclient` package to send notifications to Firebase.
```bash
composer require google/apiclient
```
3. Create a service account in Firebase and download the JSON file.
4. Add the json file to public directory.
5. Create a service to send notifications to Firebase.
```php
<?php

namespace App\Services;

use Google\Exception;
use Google_Client;

class FirebaseService
{
    /**
     * @throws Exception
     */
    public function sendPushNotification($title, $body): bool|string
    { 
        $credentialsFilePath = 'firebase/fcm.json';
        $client = new Google_Client();
        $client->setAuthConfig($credentialsFilePath);
        $client->addScope('https://www.googleapis.com/auth/firebase.messaging');
        $url = 'https://fcm.googleapis.com/v1/projects/admc-push/messages:send';
        $client->fetchAccessTokenWithAssertion();
        $accessToken = $client->getAccessToken();
        $accessToken = $accessToken['access_token'];

        $data = [
            'message' => [
                'notification' => [
                    'title' => $title,
                    'body' => $body,
                ],
                'topic' => 'all',
            ],
        ];

        $data = json_encode($data);

        $headers = [
            'Authorization: Bearer '.$accessToken,
            'Content-Type: application/json; UTF-8',
        ];

        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $data);

        $result = curl_exec($ch);

        if (curl_errno($ch)) {
            return false;
        }

        curl_close($ch);
        dd(json_decode($result, true));

        return $result;
    }
}
```
This service sends a push notification to all devices subscribed to the `all` topic. It uses the Google API client to authenticate and send the notification to Firebase Cloud Messaging (FCM).

## 4. OTP Verification
OTP verification can be implemented using emails, SMS, or other channels. 
1. Create a model and migration for storing OTPs.
```bash
php artisan make:model OTP -m
```
2. Add the following fields to the migration file.
```php
<?php

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('otps', function (Blueprint $table) {
            $table->id();
            $table->string('identifier');
            $table->string('token');
            $table->Integer('validity')->default(60);
            $table->enum('type', ['email', 'phone'])->default('email');
            $table->enum('purpose', ['email_verification', 'phone_verification', 'reset_password', 'two_factor'])->default('email_verification');
            $table->timestamps();
        });
    }

};
```
The `identifier` field stores the email or phone number of the user. The `token` field stores the OTP. The `validity` field stores the validity period of the OTP in minutes. The `type` field stores the type of OTP (email or phone). The `purpose` field stores the purpose of the OTP (email verification, phone verification, password reset, two-factor authentication).

3. Create a service to generate and validate OTPs.
```php
<?php

namespace App\Services;

use App\Localization\Message;
use App\Models\OTP;
use App\Types\HTTPResponse;
use App\Types\ResponseEmailToken;

class OTPGeneratorValidator
{
    public static function generate(string $email, int $length, int $validity, string $purpose): string
    {
        if ($length < 4) {
            $length = 4;
        }
        if ($length > 8) {
            $length = 8;
        }

        $start = pow(10, $length - 1);
        $end = pow(10, $length) - 1;
        $otp = mt_rand($start, $end);

        // convert otp to string
        $otp = (string) $otp;

        OTP::create([
            'identifier' => $email,
            'token' => $otp,
            'validity' => $validity,
            'purpose' => $purpose,

        ]);

        return $otp;
    }

    public static function validate(string $email, string $otp): ResponseEmailToken
    {
        $otp = OTP::where('identifier', $email)->where('token', $otp)->first();

        if ($otp) {
            $validity = $otp->validity;
            OTP::where('identifier', $email)->delete();
            if ($otp->created_at->diffInMinutes(now()) <= $validity) {

                return new ResponseEmailToken(true, Message::getSuccess('otpValid'),
                    HTTPResponse::OK);
            } else {

                return new ResponseEmailToken(false, Message::getError('otpExpired'),
                    HTTPResponse::GONE);
            }
        } else {
            return new ResponseEmailToken(false, Message::getError('invalidOTP'),
                HTTPResponse::BAD_REQUEST);
        }
    }

    public static function deleteOTP(string $email, string $purpose, string $type): void
    {
        OTP::where('identifier', $email)->where('purpose', $purpose)->where('type', $type)->delete();
    }
}
```
This service generates an OTP using a random number generator and stores it in the database. It also validates the OTP by checking if it matches the stored OTP and if it is within the validity period. It is useful for implementing OTP verification in registration, password reset, and other scenarios.

4. Schedule a task to delete expired OTPs.
```bash
php artisan make:command cleanOTPs
```
```php
<?php

namespace App\Console\Commands;

use App\Models\OTP;
use App\Models\PasswordResetToken;
use Illuminate\Console\Command;

class CleanOTPS extends Command
{
    protected $description = 'Clean Otp database, remove all old OTPs that is expired or used.';

    public function handle()
    {
        try {
            OTP::where('purpose', 'register')->where('created_at', '<=', now()->subMinutes(
                intval(env('SIGNUP_OTP_EXPIRY', 24 * 60 * 7))
            ))->delete();

            // login otp
            OTP::where('purpose', 'login')->where('created_at', '<=', now()->subMinutes(
                intval(env('LOGIN_OTP_EXPIRY', 15))
            ))->delete();

            // reset password token
            OTP::where('purpose', 'reset_password')->where('created_at', '<=', now()->subMinutes(
                intval(env('OTP_PASSWORD_EXPIRY', 60))
            ))->delete();

            // password reset token
            PasswordResetToken::where('created_at', '<=', now()->subMinutes(
                intval(env('OTP_PASSWORD_EXPIRY', 60))
            ))->delete();

        } catch (\Exception $e) {
            $this->error("Error:: {$e->getMessage()}");
        }

        $this->info('OTP cleaned successfully.');

    }
}
```
This command deletes expired OTPs from the database. It gets the expiry period from the environment variables and deletes OTPs that are older than the expiry period. It is useful for cleaning up the database and removing old and expired OTPs.

5. Schedule the task to run every day. In routes/console.php, add the following code:
```php
<?php

use App\Console\Commands\CleanOTPS;
use Illuminate\Console\Scheduling\Schedule;

$schedule->command(CleanOTPS::class)->daily();
```
In Laravel 10, the command scheduler is defined in the `app/Console/Kernel.php` file. 

## 5. Rate Limiting
Rate limiting can be implemented to prevent abuse of the API by limiting the number of requests a user can make in a given time period. 

1. In the `routes/api.php` file.
```php
Route::prefix('auth')->group(function () {
    // Auth routes
    Route::middleware(['throttle:5,1'])->group(function () {
         Route::post('/register', [RegisterController::class, 'register'])->middleware(['guest:sanctum']);
        Route::post('/login', [LoginController::class, 'login'])->middleware(['guest:sanctum']);
        Route::post('/admin/login', [LoginController::class, 'loginAdmin'])->middleware(['guest:sanctum']);
        Route::post('/logout', [LoginController::class, 'logout'])->middleware(['auth:sanctum']);

    });
});
```
This code limits the number of requests to the `/auth` routes to 5 requests per minute. If a user exceeds the limit, they will receive a `429 Too Many Requests` response.

## 6. Customizing Error Responses
Custom error responses can be implemented to provide more detailed and user-friendly error messages to the API consumers.

1. In the `bootstrap/app.php` file, add the following code to customize the error responses.
```php
<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Http\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        api: __DIR__.'/../routes/api.php',
        commands: __DIR__.'/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        $middleware->alias([
            'admin' => \App\Http\Middleware\IsAdmin::class,
            'customer' => \App\Http\Middleware\IsCustomer::class,
            'guest' => \App\Http\Middleware\GuestCustom::class,
            'locale' => \App\Http\Middleware\SetLocale::class,
        ]);

        $middleware->api([
            'locale',
        ]);
    })
    ->withExceptions(function (Exceptions $exceptions) {
        // custom not found exception
        $exceptions->render(function (NotFoundHttpException $e, Request $request) {
            if ($request->is('api/*')) {
                return response()->json([
                    'message' => 'Record not found.',
                ], 404);
            }
        });
    })->create();
```

This code customizes the `NotFoundHttpException` exception to return a JSON response with a `404` status code and a message `Record not found.` for API routes. It provides a more user-friendly error message for API consumers when a record is not found.

## 7. Pagination
Pagination can be implemented to limit the number of records returned in a response and provide navigation links to access additional records.

1. Create a configuration file for the application settings.
Personally, I call the configuration file by the application name, for example, `config/admc.php` for the Admc application. 

```php
<?php

return [
    'api_url' => env('API_URL', 'http://localhost:8000'),
    'api_username' => env('API_USERNAME', 'admin'),
    'api_password' => env('API_PASSWORD', 'password'),
    'frontend_url' => env('FRONTEND_URL', 'http://localhost:3000'),
    'page_size' => 10,
];

```
This configuration file contains the page size for pagination, which can be used to limit the number of records returned in a response.

2. Use the page size configuration in the controller or the service to paginate the records.
```php
  public function index(): JsonResponse
    {
        $users = User::whereHas('customer')->paginate(config('admc.page_size'));

        return response()->json([
            'data' => CustomerResource::collection($users),
        ]);
    }

```
This code uses the `page_size` configuration value to paginate the records returned by the `User` model. It limits the number of records returned in a response to 10 per page.


